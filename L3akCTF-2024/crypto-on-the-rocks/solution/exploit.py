from pwn import *
from sage.all import *
import hashlib
from utils import PartialInteger, attack, dsa_known_msb, check_public_key, curve
from Crypto.Cipher import AES
from Crypto.Util.Padding import pad, unpad
import hashlib, re
from Crypto.Util.number import long_to_bytes, bytes_to_long
import sys
p = 0x01ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff
K = GF(p)
a = K(0x01fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc)
b = K(0x0051953eb9618e1c9a1f929a21a0b68540eea2da725b99b315f3b8b489918ef109e156193951ec7e937b1652c0bd3bb1bf073573df883d2c34f1ef451fd46b503f00)
E = EllipticCurve(K, (a, b))
G = E(0x00c6858e06b70404e9cd9e3ecb662395b4429c648139053fb521f828af606b4d3dbaa14b5e77efe75928fe1dc127a2ffa8de3348b3c1856a429bf97e7e31c2e5bd66, 0x011839296a789a3bc0045c8a5fb42c7d1bd998f54449579b446817afbd17273e662c97ee72995ef42640c550b9013fad0761353c7086a272c24088be94769fd16650)
E.set_order(0x01fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffa51868783bf2f966b7fcc0148f709a5d03bb5c9b8899c47aebb6fb71e91386409 * 0x1)
n = G.order()
DEFAULT_HOST,DEFAULT_PORT = '172.17.0.2', 1337
host = sys.argv[1] if len(sys.argv) > 1 else DEFAULT_HOST
port = int(sys.argv[2]) if len(sys.argv) > 2 else DEFAULT_PORT
n_sigs = int(sys.argv[3]) if len(sys.argv) > 3 else 100
def hasher(m):
    hashed = int.from_bytes(hashlib.sha256(m.encode()).digest(), byteorder='big')
    return hashed

def parse_sig(input_string):
    pattern = r"Signature \(r,\s*s\):\s*\((\d+),\s*(\d+)\)"
    match = re.search(pattern, input_string)
    if match:
        r = int(match.group(1))
        s = int(match.group(2))
        return (r, s)
    else:
        return None

def parse_pub(s):
    x = int(re.findall(r"Public Key \(X, Y\): \((\d+),", s)[0])
    y = int(re.findall(r"Public Key \(X, Y\): \(\d+, (\d+)\)", s)[0])
    return (x, y)

def get_pub(r):
    r.recvuntil(b">> ")
    r.sendline(b"!1")
    pub = r.recvline().strip().decode()
    xy_pub = parse_pub(pub)
    print(f"[+] Public Key Received: {xy_pub} [+]")
    return xy_pub, pub

def get_sigs(n, r):
    sigs = []
    r.recvuntil(b">> ")
    r.sendline(b'!2')
    for i in range(n):
        r.recvuntil(b">> ")
        r.sendline(b"message")
        sig_line = r.recvline().strip().decode()
        parsed_sig = parse_sig(sig_line)
        if parsed_sig:
            sigs.append(parsed_sig)
        else:
            print(f"[-] Failed to parse signature: {sig_line} [-]")
    r.sendline(b"!exit")
    print(f"[+] Total Parsed Signatures: {len(sigs)} [+]")
    return sigs

def get_flag(r):
    r.recvuntil(b">> ")
    
    r.sendline(b"!4")
    dat = r.recv(1024).strip().decode()
    stripped = re.findall(r"Encrypted Flag: ([a-f0-9]+)", dat)
    print(dat)
    print(f"[+] Received Encrypted Flag: {stripped} [+]")
    if len(stripped) == 0:
        r.recvuntil(b">> ")
        r.sendline(b"!4")
        dat2 = r.recvline().strip().decode()
        print(dat2)
        stripped = re.findall(r"Encrypted Flag: ([a-f0-9]+)", dat2)[0]
        print(f"[+] Received Encrypted Flag: {stripped} [+]")
    return stripped

def decrypt_flag(ciphertext, key):
    ciphertext = bytes.fromhex(ciphertext)
    iv = ciphertext[:16]
    ciphertext = ciphertext[16:]
    cipher = AES.new(key, AES.MODE_CBC, iv)
    return unpad(cipher.decrypt(ciphertext), AES.block_size)

def main(n_sigs:int):
    r = remote(host, port)
    print("[+] Connection established with the server. [+]")
    try:
        # list of k's
        k_i = []
        # list of hashed messages
        h_i = []
        # list of r's from ecdsa signatures
        r_i = []
        # list of s' from ecdsa signatures
        s_i = []
        msg = "message"
        hashed = hasher(msg)
        # get public key
        pub, _ = get_pub(r)
        # get n signatures
        sigs = get_sigs(n_sigs, r)
        # get the encrypted flag
        flag = get_flag(r)
        # partial integer for biased k's
        ks = PartialInteger.from_bits_be("000000000"+("?"*512))
        for r_s, s in sigs:
            r_s_i = str(r_s).replace(",", "")
            s_i.append(int(s))
            r_i.append(int(r_s_i))
            k_i.append(ks)
            h_i.append(hashed)
        print(f"[+] Arrays lengths\n-> h_i: {len(h_i)}\n-> r_i: {len(r_i)}\n-> s_i: {len(s_i)}\n-> k_i: {len(k_i)}\n[+]")
        
        for d_, _ in dsa_known_msb(n, h_i, r_i, s_i, k_i):
            if check_public_key(int(d_), curve, pub[0], pub[1]):
                print("[+] Success: Correct private key found. [+]")
                print(f"[+] Private Key: {d_} [+]")
                print(f"[+] AES_KEY: {hashlib.sha256(long_to_bytes(int(d_))).hexdigest()} [+]")
                dec_flag = decrypt_flag(flag, hashlib.sha256(long_to_bytes(int(d_))).digest())
                print(f"[+] Decrypted Flag: {dec_flag.decode()} [+]")
                print(f"/[+]\\After {n_sigs} signatures, private key has been successfully recovered and the flag decrypted /[+]\\")
                break
            else:
                print("Unsuccessful attack on attempt #")
    finally:
        r.close()
        print("Connection closed.")

if __name__ == "__main__":
    main(n_sigs)
