# Cop or smith Solution writeup
- **Category**: Crypto
- **Difficulty**: Hard
- **Author**: supasuge


In this challenge, the RSA encryption process is straight forward, with small variations in the prime factors ($p$, $q$) used to generate the modulus $N$. While the primes $p$ and $q$ are large, they follow a specific relation in how they are generated which allows us to apply the Coppersmith's Method to recover the modulus $N$, and use the relation's to find $p$, and $q$ along as the private key to decrypt the flag. The challenge name `Cop or smith` was meant to be a direct hint toward's how to solve. There are many writeup's and article's online about how to apply the univariate, multi

In `output.txt` you are give two encrypted messages `msg1`, and `msg2` with known plaintexts (`"Can't factor the modulus"`, and `"If you don't know the modulus... ;)"` respectively), as well as the encrypted `flag` however you aren't given the modulus $N$, which add's a bit of difficulty to solving this challenge. 

## Source Code analysis
```python
from sage.all import *
from random import randint
from Crypto.Util.number import bytes_to_long

def rsa(msg, e, n):
    return pow(bytes_to_long(msg), e, n)

flag = open('flag.txt', 'r').read().strip().encode()
tmp = randint(2**1023, 2**1024)
e = 65537
p = next_prime(0xBEEF * tmp + randint(2, 2**500))
q = next_prime(0xDEAD * tmp + randint(2, 2**500))
N = p * q
```

### Key Observations 
- Both $p$ and $q$ are generated by adding a small random value to a multiple of fixed constants (`0xBEEF` and `0xDEAD` respectively) then taking the next prime.
- Two known plaintext's are given to us along as the encrypted flag. The known plaintext's are vital towards obtaiing the public modulus $N$, then utilizing this information for factorization of $p$ and $q$ by approximating these values in relation to the known plaintexts.

### Solution
- As a reminder, RSA encryption/decryption and key generation is simply:
- $N$ = Public modulus, commonly known as public key.
    - $e$ = public exponent, typically 65537 in practice.

$$
N = p * q
$$ 

- Euler's totient function $ϕ(N)$

$$
phi = (p-1) * (q-1)
$$

- Private key calculation

$$
d = e^{-1} \mod phi
$$

- Encryption

$$
ct = m^{e} \mod N
$$

- Decryption

$$
pt = ct^{d} \mod N
$$


### Step 1: Recovering N.

To find $N$ let's write the ciphertext `msg1` as $c_1$, and `msg2` as $c_2$. We then write:

$$
c_1 = m_1^{e} \mod n
$$

$$
c_2 = m_2^{e} \mod n
$$

- Where $m_1$, and $m_2$ are known plaintexts, we can compute:

$$
s_1 = m_1^{e} - c_1 = k_1 * n \nonumber
$$ 

$$
s_2 = m_2^{e} - c_2 = k_2 * n \nonumber
$$

$$
n = {gcd(s1,s2)} \nonumber
$$
- k should be small here.
- Since both $s_1$, and $s_2$ are multiples of N, the GCD of $n_1$, and $n_2$ yields $N$.

Here's an example to find $N$:

[m.sage](https://github.com/supasuge/HackDearbornCTF-2024-Private/crypto/cop-or-smith/solution/m.sage) 
```python
#!/usr/bin/env sage
from sage.all import *
msg1 = 32332308151004740321270161371401779482629933250081757734598524562496477161204680894784549824667278078558086734945432732885203545490444272717812609145473170346737703306915184619801184010910835350302564374124974054995391665731536178034641894984420412533152266919470522212937561740201234390064552390119902987305854977134154649014242415085781627677160573776419356351702162042002112812791319450230935602408452814829529723015494108678896298255344340225987249009557720805693967586744275418046038586919636925605325756458305887683238626926001036007806958391030030435910443373846530580641386973618765354653655363625221470061928960149180
msg2 = 12302880109777731579694015901024408759668209721287671911804219543370185229079350587454525467596442416727893439631241375365353119445154554944370787072754973895786153199307746770980290454449281685187862903634208621945795887220232851057185385095424972972205752015805246292845900149127234241407693850534344484408253307382543241817464988792029878986597599662945427372962257457142438455055182334487120803109625974952443268974931700576258647996245545394032590970812933662610480362140354007862460475950159177532733430385622071694992414609139450079989255019589536381126142601731561830001493272241831178319292334707268308076684367654673
flag = 19958145637668326649010928240490139773351555479680728380032347851362607303785448088807150691078242360738218331515116334350201854779273823506142672702123607432804328508079712221008618751556613342622767381098010498911472437896350579747758111040865171655030268871338533096552497695592126861893683285535721495273863990822863466870360899551593899094760948975570772118388626427873597377243856567921895757452519029872265230753499869386032658032432637080529773774728055905220245440354232574827445406861384817046195022155029671851057361065814531157154740376698491661628249940131000223432987441125504290950975497567867004905577862828415
e = 65537
m1 = bytes_to_long("Can't factor the modulus")
m2 = bytes_to_long("If you don't know the modulus... ;)")
print("Computing m1^e and m2^e. Might take a little bit...")
n1 = m1^e - msg1
n2 = m2^e - msg2
N = gcd(n1, n2)
print("Found N: ", N)
```

- Note in python, `n1` and `n2` would be:
```python
n1 = m1**e - msg1
n2 = m2**e - msg2
```
Sage is just different.

**Outputs:**
```sh
$ sage getmodulus.sage
Computing m1^e and m2^e. Might take a little bit...
Found N: 44963937755126374600334664481047432078590558677526448528255232533042900843393641503004220799608838249925381196982605560666973569980106311963242367582725806676380658554255547269782511939326650626475331312464425452541775827305809667591457674398836888834654269011725897965880438737921864382464677562154205500180134809010391946735114201783575080627053126658891559422053210040012568026170188205232160692259245605854601350566778664814242413651704640695504937477629828902132201610845226521262014355203221267288377826783451902169763284473739810831880089905194509347411113311183082865127317917012540908681244194954808967336370106883771
```

**Step 2: Approximating Prime Factors**
- Given the structure of the prime generation from the challenge:

$$
p \approx \text{nextprime}(0x\text{BEEF} \times \text{tmp})
$$
$$
q \approx \text{nextprime}(0x\text{DEAD} \times \text{tmp})
$$

We can approximate the ratio $r = \frac{0x\text{DEAD}}{0x\text{BEEF}}$ to relate $p$ and $q$:
  
$$
r = \frac{0x\text{DEAD}}{0x\text{BEEF}} \approx \frac{57005}{48879} \approx 1.166
$$
  
$$
r = \frac{0x\text{BEEF}}{0x\text{DEAD}} \approx \frac{48879}{57005} \approx 1.166
$$

Assuming $p$ and $q$ are close to their respective multiples, we can approximate $p$ and $q$ as:
  
$$
p \approx \sqrt{N \times r}
$$

$$
q \approx \sqrt{\frac{N}{r}}
$$

**Implementation:***
```python
# Approximation of p and q from their relation
x1, x2 = 0xDEAD, 0xBEEF
r = x1 / x2

# Estimating p' (close to p)
nn = RealField(2000)(N)
pp = int(sqrt(nn * r))
```

### Step 3: Applying Coppersmith's method

Coppersmith's method is used to find small roots of univariate modular equations. In this case, we set up a polynomial equation where the difference between the appraoximated prime $p'$ and the actual prime $p$ is small:

$$
f(x) = p' - x \mod N
$$

Our goal is to find $x$ such that $p = p' - x$; given that $x$ is small relative to $p$, Coppersmith's method can efficiently find $x$:
- **Polynomial**: $f(x) = x - p'$
- **Bound $X$**: An upper bound on $|x|$, we set $X = 2^{500}$, assuming $x$ is less than this value$
- **Coppersmith's Condition**: The method works effectively if $p$ is greater than $N^\beta$ for some $\beta < \frac{1}{2}$. We choose $\beta = 0.4$.

Implementation:

```python
# Using Coppersmith’s method to find small difference
F.<x> = PolynomialRing(Zmod(N), implementation='NTL')
pol = x - pp

beta = 0.4  # p >= N^beta
X = 2**500  # bound on |pp -p| < x

# Finding small roots
roots = pol.small_roots(X=X, beta=beta)
if roots:
    p = int(pp - roots[0])
    print(f"Found p: {p}\n")
    q = N // p
    assert p * q == N
    print(f"Found q: {q}\n")

    # Calculate private key 'd'
    phi = (p - 1) * (q - 1)
    d = inverse_mod(e, phi)
    print(f"Found d: {d}\n")

    # Decrypting the flag
    decrypted_flag = pow(flag, d, N)
    print(f"Flag: {long_to_bytes(decrypted_flag)}")
else:
    print("Failed to find small roots for p.")
```

### Step 4: Calculating the Private Key and Decrypting the Flag
With $p$ and $q$ known, compute euler's totient function $ϕ(N)$

$$
ϕ(N) = (p-1) * (q-1)
$$

Private key is the modular inverse of $e$ ($65537$) module $ϕ(N)$:

$$
d = e^{-1} \mod ϕ(N)
$$

Finally, decrypting the flag:

$$
flag = flag^{d} \mod N
$$

**Implementation:**

```python
# Calculate private key 'd'
phi = (p - 1) * (q - 1)
d = inverse_mod(e, phi) # uses sagemath's inverse_mod() function for fast calculation
print(f"Found d: {d}\n")
decrypted_flag = pow(flag, d, N) # decrypting flag
print(f"Flag: {long_to_bytes(decrypted_flag)}") # printing as plaintext, converting integer to bytes
```

**Full solution code + Output:**

```python
from sage.all import *
from random import randint

# Function to convert string to long integer
def bytes_to_long(data):
    return int(data.encode().hex(), 16)
# vise versa of above function
def long_to_bytes(data):
    return bytes.fromhex(hex(data)[2:]).decode()

# give values from output.txt
msg1 = 32332308151004740321270161371401779482629933250081757734598524562496477161204680894784549824667278078558086734945432732885203545490444272717812609145473170346737703306915184619801184010910835350302564374124974054995391665731536178034641894984420412533152266919470522212937561740201234390064552390119902987305854977134154649014242415085781627677160573776419356351702162042002112812791319450230935602408452814829529723015494108678896298255344340225987249009557720805693967586744275418046038586919636925605325756458305887683238626926001036007806958391030030435910443373846530580641386973618765354653655363625221470061928960149180
msg2 = 12302880109777731579694015901024408759668209721287671911804219543370185229079350587454525467596442416727893439631241375365353119445154554944370787072754973895786153199307746770980290454449281685187862903634208621945795887220232851057185385095424972972205752015805246292845900149127234241407693850534344484408253307382543241817464988792029878986597599662945427372962257457142438455055182334487120803109625974952443268974931700576258647996245545394032590970812933662610480362140354007862460475950159177532733430385622071694992414609139450079989255019589536381126142601731561830001493272241831178319292334707268308076684367654673
flag = 19958145637668326649010928240490139773351555479680728380032347851362607303785448088807150691078242360738218331515116334350201854779273823506142672702123607432804328508079712221008618751556613342622767381098010498911472437896350579747758111040865171655030268871338533096552497695592126861893683285535721495273863990822863466870360899551593899094760948975570772118388626427873597377243856567921895757452519029872265230753499869386032658032432637080529773774728055905220245440354232574827445406861384817046195022155029671851057361065814531157154740376698491661628249940131000223432987441125504290950975497567867004905577862828415
e = 65537

# known plaintext's expressed as long integers
m1 = bytes_to_long("Can't factor the modulus")
m2 = bytes_to_long("If you don't know the modulus... ;)")

# Finding N from the given equations
print("Computing m1^e and m2^e. Might take a little bit...")
n1 = m1^e - msg1
n2 = m2^e - msg2
N = gcd(n1, n2)
print(f"Found N: {N}\n")

# Approximation of p and q from their relation
x1, x2 = 0xDEAD, 0xBEEF
r = x1 / x2

# Estimating p' (close to p)
nn = RealField(2000)(N)
pp = int(sqrt(nn * r))

# Using Coppersmith’s method to find small difference
F.<x> = PolynomialRing(Zmod(N), implementation='NTL')
pol = x - pp

beta = 0.4  # p >= N^beta
X = 2**500  # bound on |pp -p| < x

# Finding small roots
roots = pol.small_roots(X=X, beta=beta)
if roots:
    p = int(pp - roots[0])
    print(f"Found p: {p}\n")
    q = N // p
    assert p * q == N
    print(f"Found q: {q}\n")

    # Calculate private key 'd'
    phi = (p - 1) * (q - 1)
    d = inverse_mod(e, phi)
    print(f"Found d: {d}\n")

    # Decrypting the flag
    decrypted_flag = pow(flag, d, N)
    print(f"Flag: {long_to_bytes(decrypted_flag)}")
else:
    print("Failed to find small roots for p.")
```

---

**Output**
```sh
$ sage solve.sage                            

Computing m1^e and m2^e. Might take a little bit...
Found N: 44963937755126374600334664481047432078590558677526448528255232533042900843393641503004220799608838249925381196982605560666973569980106311963242367582725806676380658554255547269782511939326650626475331312464425452541775827305809667591457674398836888834654269011725897965880438737921864382464677562154205500180134809010391946735114201783575080627053126658891559422053210040012568026170188205232160692259245605854601350566778664814242413651704640695504937477629828902132201610845226521262014355203221267288377826783451902169763284473739810831880089905194509347411113311183082865127317917012540908681244194954808967336370106883771

Found p: 7241482539500635371707204499998804385225975854323354354152321269961657604178561019473170865383888043512012360329253640380739127837725710789356469482213786145459343702878850977094603538696026106492264681468273385740041924908034861775947519910364988625872783867994833433582404337861595426261022433020923403760203311

Found q: 6209217174778555500985465288228077529084474586149833128262631547310865047533442401031999276012614045764821544786134351165163544067716779539916759439016360898235367371918956505655843652950339577834552161955969665418554699020283649452482437726455991532326910786541963312642412789682613076169070400993704686762903861

Found d: 5063991708051753527397808238622626854632908335731307758778275955969752218213962615525186592640994173103731306207617248932403557074983058251074841923312009690378956021620766809561998880390771751438338959935607737083034734292753424119086151254067398209997149084876464483973381728254288127423772603052629671740079267070907859190337825839143872365315222215601017729856080314945237351613172205876395491415607644067181769324539415419002359809811413688488957736189985802324220678074769578571156717193406085600964351789882618605933475763293900069139197194694956377581928981764439774347436557365981751425504783045397822999829281289273

Flag: hd3{following_bruce_the_goose}
```

Flag: `hd3{following_bruce_the_goose}`


Thanks for reading!
